# TCHAR

TCHAR 就是当你的字符设置为什么就是什么
例如：程序编译为 ANSI， TCHAR 就是相当于 char
当程序编译为 [UNICODE](https://so.csdn.net/so/search?q=UNICODE&spm=1001.2101.3001.7020)， TCHAR 就相当于 wchar

- char :单字节变量类型，最多表示256个字符，

- wchar_t :宽字节变量类型，用于表示Unicode字符，定义在<string.h>里：typedef unsigned short wchar_t。

为了让编译器识别Unicode字符串，必须以在前面加一个“L”,定义宽字节类型方法如下：

```c++
 wchar_t c = 'A' ; 

wchar_t * p = L"Hello!" ; 

wchar_t a[] = L"Hello!" ;

//sizeof(a)=14
```

其中，宽字节类型每个变量占用2个字节，故上述数组a的sizeof(a) = 14

- 在字符串前加一个L作用: 
    如 L"我的字符串"  表示将ANSI字符串转换成unicode的字符串，就是每个字符占用两个字节。 

-  _T宏可以把一个引号引起来的字符串，根据你的环境设置，使得编译器会根据编译目标环境选择合适的（Unicode还是ANSI）字符处理方式 
  - 如果你定义了UNICODE，那么_T宏会把字符串前面加一个L。这时 _T("ABCD") 相当于 L"ABCD" ，这是宽字符串。 
  - _如果没有定义，那么_T宏不会在字符串前面加那个L，_T("ABCD") 就等价于 "ABCD" 

- TEXT,_TEXT 和_T 一样的 
  如下面三语句： 

  - ```c++
     TCHAR  szStr1[]  =  TEXT("str1"); 
     char  szStr2[]  =  "str2"; 
     WCHAR  szStr3[]  =  L("str3"); 
    ```

  

  - 那么第一句话在定义了`UNICODE`时会解释为第三句话，没有定义时就等于第二句话。 
  - 但二句话无论是否定义了`UNICODE`都是生成一个`ANSI`字符串，而第三句话总是生成`UNICODE`字符串。  

如果在程序中既包括`ANSI`又包括`Unicode`编码，需要包括头文件`tchar.h`。`TCHAR`是定义在该头文件中的宏，它视你是否定义了_UNICODE宏而定义成： 
定义了`_UNICODE：  typedef wchar_t TCHAR ; `
没有定义`_UNICODE： typedef char TCHAR ;`

```c++
\#ifdef UNICODE 
typedef char TCHAR; 
\#else 
typede wchar_t TCHAR; 
\#endif 
```
`_T( )`也是定义在该头文件中的宏，视是否定义了 `_UNICODE` 宏而定义成： 
定义了：`_UNICODE：  #define _T(x) L##x `
没有定义：`_UNICODE： #define _T(x) x `
注意：如果在程序中使用了TCHAR，那么就不应该使用ANSI的strXXX函数或者Unicode的wcsXXX函数了，而必须使用tchar.h中定义的_tcsXXX函数

# 	创建子进程

模板：

```c++
// 创建传递过来的进程的克隆过程并赋于其ID值
void StartClone(int nCloneID)
{
    // 提取用于当前可执行文件的文件名
    TCHAR szFilename[MAX_PATH] ;
    GetModuleFileName(NULL, szFilename, MAX_PATH) ;
    
	//std::cout<<"szFilename[]="<<szFilename<<'\n';
	
    // 格式化用于子进程的命令行并通知其EXE文件名和克隆ID
    TCHAR szCmdLine[MAX_PATH];
	sprintf(szCmdLine,"\"%s\" %d",szFilename,nCloneID);
	
	//std::cout<<"szCmdLine[]="<<szCmdLine<<'\n';
	
	// 用于子进程的STARTUPINFO结构
    STARTUPINFO si;
    ZeroMemory(&si , sizeof(si) ) ;
    si.cb = sizeof(si) ;				// 必须是本结构的大小
    
	//std::cout<<"si.cd="<<si.cb<<'\n';
	
    // 返回的用于子进程的进程信息
    PROCESS_INFORMATION pi;

    // 利用同样的可执行文件和命令行创建进程，并赋于其子进程的性质
    BOOL bCreateOK=::CreateProcess(
        szFilename,					// 产生这个EXE的应用程序的名称	argc
        szCmdLine,					// 告诉其行为像一个子进程的标志	argv
        NULL,						// 缺省的进程安全性
        NULL,						// 缺省的线程安全性
        FALSE,						// 不继承句柄
        //CREATE_NEW_CONSOLE,		// 使用新的控制台
		0,							// 使用老的控制台
        NULL,						// 新的环境
        NULL,						// 当前目录
        &si,						// 启动信息
        &pi) ;						// 返回的进程信息
        
	//std::cout<<bCreateOK<<'\n';
    
    // 对子进程释放引用
    if (bCreateOK)
    {
        CloseHandle(pi.hProcess) ;
        CloseHandle(pi.hThread) ;
    }
}
```

# 互斥对象

**互斥对象**是一个同步对象，其状态设置为在任何线程不拥有时发出信号，并在其拥有时不对齐。 一次只有一个线程可以拥有互斥体对象，其名称来自协调对共享资源的互斥访问很有用的事实。 例如，为了防止两个线程同时写入共享内存，每个线程在执行访问内存的代码之前等待互斥对象的所有权。 写入共享内存后，线程将释放互斥体对象。

# win下的进程简单通信与终止程序

## WaitForSingleObject

`WaitForSingleObject`函数用来检测`hHandle`事件的信号状态，在某一线程中调用该函数时，线程暂时挂起，如果在挂起的`dwMilliseconds`毫秒内，线程所等待的对象变为有信号状态，则该函数立即返回；如果时间已经到达`dwMilliseconds`毫秒，但`hHandle`所指向的对象还没有变成有信号状态，函数照样返回。

```c++
DWORD WINAPI WaitForSingleObject(
__in HANDLE hHandle,
__in DWORD dwMilliseconds
);
```

*hHandle*[in]对象句柄。可以指定一系列的对象，如Event、Job、Memory resource notification、Mutex、Process、Semaphore、Thread、Waitable timer等。

`dwMilliseconds[in]`定时时间间隔，单位为`milliseconds`（毫秒）.如果指定一个非零值，函数处于等待状态直到`hHandle`标记的对象被触发，或者时间到了。如果`dwMilliseconds`为`0`，对象没有被触发信号，函数不会进入一个等待状态，它总是立即返回。如果`dwMilliseconds`为`INFINITE`，对象被触发信号后，函数才会返回。

## OpenMutex

```c++
 HANDLE OpenMutex(
DWORD dwDesiredAccess, 	// access
BOOL bInheritHandle, 	// inheritance option
LPCTSTR lpName 			// object name
);
```

**dwDesiredAccess：**

- `MUTEX_ALL_ACCESS` 请求对互斥体的完全访问

- `MUTEX_MODIFY_STATE` 允许使用 `ReleaseMutex` 函数

- `SYNCHRONIZE` 允许互斥体对象同步使用

**bInheritHandle** : 如希望子进程能够继承句柄，则为`TRUE`

l**pName** ：要打开对象的名字

返回值：如执行成功，返回对象的句柄；零表示失败。若想获得更多错误信息，请调用GetLastError函数。

备注：一旦不再需要，注意一定要用 `CloseHandle` 关闭互斥体句柄。如对象的所有句柄都已关闭，那么对象也会删除

# Liunx 进程

# exit(0)

终结进程

## wait

```c++
int wait(int *status)
```

父进程一旦调用了wait就立即阻塞自己，由wait自动分析是否当前进程的某个子进程已经退出，如果让它找到了这样一个已经变成僵尸的子进程，wait就会收集这个子进程的信息，并把它彻底销毁后返回；如果没有找到这样一个子进程，wait就会一直阻塞在这里，直到有一个出现为止。

## waitpid

```c++
 pid_t  waitpid(pid_t pid,  int *status,  int options)
```

**pid**：

从参数的名字pid和类型pid_t中就可以看出，这里需要的是一个进程ID。但当pid取不同的值时，在这里有不同的意义。

- pid>0时，只等待进程ID等于pid的子进程，不管其它已经有多少子进程运行结束退出了，只要指定的子进程还没有结束，waitpid就会一直等下去。
- pid=-1时，等待任何一个子进程退出，没有任何限制，此时waitpid和wait的作用一模一样。
- pid=0时，等待同一个进程组中的任何子进程，如果子进程已经加入了别的进程组，waitpid不会对它做任何理睬。
- pid<-1时，等待一个指定进程组中的任何子进程，这个进程组的ID等于pid的绝对值。

**options**：

options提供了一些额外的选项来控制waitpid，目前在Linux中只支持WNOHANG和WUNTRACED两个选项，这是两个常数，可以用"|"运算符把它们连接起来使用，比如：

     ret = waitpid(-1,  NULL,  WNOHANG | WUNTRACED);

如果我们不想使用它们，也可以把options设为0，如：

     ret = waitpid(-1,  NULL,  0);

如果使用了WNOHANG参数调用waitpid，即使没有子进程退出，它也会立即返回，不会像wait那样永远等下去。

而WUNTRACED参数，由于涉及到一些跟踪调试方面的知识，加之极少用到，这里就不多费笔墨了，有兴趣的读者可以自行查阅相关材料。

# Liunx进程通信

## msgget

```c++
int msgget(key_t key, int msgflg)
```

**key:**

- `0(IPC_PRIVATE)`：会建立新的消息队列
- 大于0的32位整数：视参数msgflg来确定操作。通常要求此值来源于ftok返回的IPC键值

**msgflg**

- 0：取消息队列标识符，若不存在则函数会报错
- `IPC_CREAT`：当`msgflg&IPC_CREAT`为真时，如果内核中不存在键值与key相等的消息队列，则新建一个消息队列；如果存在这样的消息队列，返回此消息队列的标识符
- `IPC_CREAT|IPC_EXCL`：如果内核中不存在键值与key相等的消息队列，则新建一个消息队列；如果存在这样的消息队列则报错

**返回值：**

- 成功：返回消息队列的标识符
- 出错：-1，错误原因存于error中

**错误：**

- EACCES：指定的消息队列已存在，但调用进程没有权限访问它

- EEXIST：key指定的消息队列已存在，而msgflg中同时指定IPC_CREAT和IPC_EXCL标志

- ENOENT：key指定的消息队列不存在同时msgflg中没有指定IPC_CREAT标志

- ENOMEM：需要建立消息队列，但内存不足

- ENOSPC：需要建立消息队列，但已达到系统的限制

## msgrcv

```c++
ssize_t msgrcv(int msqid, void *msgp, size_t msgsz, long msgtyp,int msgflg);
```

从标识符为msqid的消息队列读取消息并存于msgp中，读取后把此消息从消息队列中删除

**msqid：**消息队列标识符

**msgp：**存放消息的结构体，结构体类型要与msgsnd函数发送的类型相同

**msgsz：**要接收消息的大小，不含消息类型占用的4个字节

**msgtyp：**

-  `0`：接收第一个消息
- `>0`：接收类型等于msgtyp的第一个消息
- `<0`：接收类型等于或者小于msgtyp绝对值的第一个消息

**msgflg：**

-  `0`: 阻塞式接收消息，没有该类型的消息msgrcv函数一直阻塞等待
- `IPC_NOWAIT`：如果没有返回条件的消息调用立即返回，此时错误码为ENOMSG
- `IPC_EXCEPT`：与msgtype配合使用返回队列中第一个类型不为msgtype的消息
- `IPC_NOERROR`：如果队列中满足条件的消息内容大于所请求的size字节，则把该消息截断，截断部分将被丢弃

**返回值：**

- 成功：实际读取到的消息数据长度
- 出错：-1，错误原因存于error中

**错误：**

- E2BIG：消息数据长度大于msgsz而msgflag没有设置IPC_NOERROR

- EIDRM：标识符为msqid的消息队列已被删除

- EACCESS：无权限读取该消息队列

- EFAULT：参数msgp指向无效的内存地址

- ENOMSG：参数msgflg设为IPC_NOWAIT，而消息队列中无消息可读

- EINTR：等待读取队列内的消息情况下被信号中断

## msgctl

```c++
int msgctl(int msqid, int cmd, struct msqid_ds *buf)
```

 获取和设置消息队列的属性

**msqid：** 消息队列标识符

**cmd：**

- `PC_STAT：`获得msgid的消息队列头数据到buf中
- `IPC_SET：`设置消息队列的属性，要设置的属性需先存储在buf中，可设置的属性包括：msg_perm.uid、msg_perm.gid、msg_perm.mode以及msg_qbytes
- `IPC_RMID：`从系统中删除由shmid标识的共享内存区

**buf：**消息队列管理结构体，请参见消息队列内核结构说明部分

**返回值：**

- 成功：0
- 出错：-1，错误原因存于error中

**错误：**

- EACCESS：参数cmd为IPC_STAT，确无权限读取该消息队列

- EFAULT：参数buf指向无效的内存地址

- EIDRM：标识符为msqid的消息队列已被删除

- EINVAL：无效的参数cmd或msqid

- EPERM：参数cmd为IPC_SET或IPC_RMID，却无足够的权限执行

# win下的生产者消费者问题

## CreateMutex

```c++
HANDLE CreateMutex(
LPSECURITY_ATTRIBUTES lpMutexAttributes, 	// 指向安全属性的指针
BOOL bInitialOwner, 						// 初始化互斥对象的所有者
LPCTSTR lpName 								// 指向互斥对象名的指针
);
```

CreateMutex()函数可用来创建一个有名或无名的互斥量对象

- `lpMutexAttributes SECURITY_ATTRIBUTES`，指定一个`SECURITY_ATTRIBUTES`结构，或传递零值（将参数声明为ByVal As Long，并传递零值），表示使用不允许继承的默认描述符
- `bInitialOwner BOOL`，如创建进程希望立即拥有互斥体，则设为TRUE。一个互斥体同时只能由一个线程拥有
- `lpName String`，指定互斥体对象的名字。用`vbNullString`创建一个未命名的互斥体对象。如已经存在拥有这个名字的一个事件，则打开现有的已命名互斥体。这个名字可能不与现有的事件、信号机、可等待计时器或文件映射相符

互斥体是操作系统中常用的一种线程同步机制，它主要用于保护临界区（Critical Section）的访问，从而避免多个线程同时执行临界区代码而导致的问题。在实际应用中，我们可以使用互斥体来确保某个资源在同一时间只能被一个线程访问，从而保证数据的正确性和一致性。

## CreateSemaphore

```c++
HANDLE CreateSemaphore(
    LPSECURITY_ATTRIBUTES lpSemaphoreAttributes, // SD
    LONG lInitialCount, // initial count
    LONG lMaximumCount, // maximum count
    LPCTSTR lpName// object name
);
```

创建一个新的信号量

- `lpSemaphoreAttributes SECURITY_ATTRIBUTES`，指定一个`SECURITY_ATTRIBUTES`结构，或传递零值（将参数声明为ByVal As Long，并传递零值）——表示采用不允许继承的默认描述符。该参数定义了信号量的安全特性

- `lInitialCount Long`，设置信号量的初始计数。可设置零到l`MaximumCount`之间的一个值

- `lMaximumCount Long`，设置信号量的最大计数

- `lpName String`，指定信号量对象的名称。用`vbNull String`可创建一个未命名的信号量对象。如果已经存在拥有这个名字的一个信号量，就直接打开现成的信号量。这个名字可能不与一个现有的互斥体、事件、可等待计时器或文件映射的名称相符

信号量是操作系统中常用的一种线程同步机制，它主要用于控制共享资源的访问。在实际应用中，我们可以使用信号量来限制同时访问某个资源的线程数量，从而避免数据竞争和死锁等问题。

## CreateThread

```c++
HANDLE CreateThread(
    LPSECURITY_ATTRIBUTES lpThreadAttributes,
    SIZE_T dwStackSize,
    LPTHREAD_START_ROUTINE lpStartAddress,
    LPVOID lpParameter,
    DWORD dwCreationFlags,
    LPDWORD lpThreadId
);
```

- `lpThreadAttributes：`指向`SECURITY_ATTRIBUTES`结构体的指针，用于描述新线程的安全属性。如果该参数为 NULL，则表示使用默认安全属性。

- `dwStackSize：`新线程的堆栈大小，如果为0则使用默认大小。

- `lpStartAddress：`指向线程函数的指针，该函数将在新线程中运行。
- `lpParameter：`传递给线程函数的参数，如果不需要传递参数则可传入NULL。
- `dwCreationFlags：`线程的创建标志位，例如是否立即启动线程等。
- `lpThreadId：`指向线程ID变量的指针，用于返回新线程的ID号。

该函数返回一个 HANDLE 类型的线程句柄，如果创建失败则返回 NULL。

线程是操作系统中最小的调度单位，它可以独立执行一段程序代码，并与其他线程并发执行。在实际应用中，我们可以使用多线程编程来提高程序的性能和响应速度，例如同时执行多件任务、加速数据处理、优化网络通信等。

## SECURITY_ATTRIBUTES

```c++
typedef struct _SECURITY_ATTRIBUTES {
    DWORD nLength;
    LPVOID lpSecurityDescriptor;
    BOOL bInheritHandle;
} SECURITY_ATTRIBUTES, *PSECURITY_ATTRIBUTES, *LPSECURITY_ATTRIBUTES;
```

各个成员的含义如下：

- `nLength：`结构体大小，以字节为单位。
- `lpSecurityDescriptor：`指向 SECURITY_DESCRIPTOR 结构体的指针，用于描述对象的安全描述符。如果该参数为 NULL，则表示使用默认安全设置。
- `bInheritHandle：`句柄继承标识，表示当前对象的句柄是否可以被其子进程继承。如果该参数为 TRUE，则表示句柄可以被继承；如果为 FALSE，则表示句柄不能被继承。

`SECURITY_ATTRIBUTES `结构体主要用于指定对象的安全属性，它常用于创建诸如信号量、互斥体、文件、进程等系统资源时提供安全保障。通过配置对象的安全属性，我们可以限制访问该对象的用户和进程，并保护这些系统资源不被恶意用户或程序进行非法访问。

## WaitForSingleObject 

```c++
DWORD WaitForSingleObject(
  HANDLE hHandle,
  DWORD  dwMilliseconds
);
```

函数参数的含义如下：

- `hHandle：`要等待的内核对象句柄。该对象可以是诸如互斥对象、信号量、事件等同步内核对象。
- `dwMilliseconds：` 等待超时时间。如果设为 INFINITE，则表示无限等待直到对象变为可用状态；如果设为一个非零值，则表示等待指定毫秒数后超时返回。

等待一个内核对象变为可用状态。

## ReleaseMutex

用于释放一个互斥对象

```c++
BOOL ReleaseMutex(
    HANDLE hMutex
);
```

- `hMutex`：要释放的互斥对象句柄。

该函数的作用是释放该互斥对象，以允许其他等待该互斥对象的线程访问受互斥保护的资源。如果当前线程没有获取到该互斥对象的所有权，那么该函数将返回 FALSE。

## ReleaseSemaphore

用于释放一个信号量对象（Semaphore）

```c++
BOOL ReleaseSemaphore(
    HANDLE hSemaphore,
    LONG   lReleaseCount,
    LPLONG lpPreviousCount
);
```

函数参数的含义如下：

- `hSemaphore`：要释放的信号量对象句柄。
- `lReleaseCount`：要释放的信号量计数。如果该值大于 1，则表示一次性释放多个信号量。如果该值为 1，则表示只释放一个信号量。
- `lpPreviousCount`：指向 LONG 类型变量的指针。如果不为 NULL，则该变量将被赋值为释放前的信号量计数。

# win下的内存管理

## SYSTEM_INFO

用于保存系统信息

```c++
typedef struct _SYSTEM_INFO {
  union {
    DWORD  dwOemId;
    struct {
      WORD wProcessorArchitecture;
      WORD wReserved;
    };
  };
  DWORD     dwPageSize;
  LPVOID    lpMinimumApplicationAddress;
  LPVOID    lpMaximumApplicationAddress;
  DWORD_PTR dwActiveProcessorMask;
  DWORD     dwNumberOfProcessors;
  DWORD     dwProcessorType;
  DWORD     dwAllocationGranularity;
  WORD      wProcessorLevel;
  WORD      wProcessorRevision;
} SYSTEM_INFO, *LPSYSTEM_INFO;
```

- `dwPageSize` 表示系统的页大小（单位为字节）。
- `lpMinimumApplicationAddress` 和 `lpMaximumApplicationAddress` 分别表示当前进程能够使用的最小和最大内存地址空间。
- `dwActiveProcessorMask` 表示当前系统中处于活动状态的处理器掩码。
- `dwNumberOfProcessors` 表示当前系统中的处理器数量。
- `dwProcessorType` 表示当前系统中处理器的类型。
- `dwAllocationGranularity` 表示内存分配粒度。
- `wProcessorLevel` 表示处理器等级。
- `wProcessorRevision` 表示处理器的版本。

结构体中还包含了一个匿名的联合类型，用于保存处理器的架构类型。在这个联合类型中:

- `dwOemId` 表示 OEM ID
- `wProcessorArchitecture` 表示处理器的架构类型（例如 x86、x64 等），`wReserved` 为保留字段。



##    ZeroMemory

它的作用相当于将一块内存在指定的长度范围内全部填充为零。用于快速清空内存中的数据

```c++
void ZeroMemory(
  PVOID Destination, // 内存起始地址
  SIZE_T Length       // 需要清空的字节数
);
```

- `Destination` 参数表示要清空的内存起始地址
- `Length` 参数表示需要清空的字节数。

这个函数会将从 `Destination` 开始的 `Length` 个字节全部清零，即将这段内存区域设置为全零。

## GetSystemInfo

用于获取当前系统的硬件和软件配置信息

```c++
VOID WINAPI GetSystemInfo(
  LPSYSTEM_INFO lpSystemInfo // 系统信息结构体指针
);
```

- `lpSystemInfo` 参数是一个指向 `SYSTEM_INFO` 结构体的指针，用于存储查询到的系统信息。

调用这个函数后，系统会将当前系统的硬件和软件配置信息填充到 `lpSystemInfo` 指向的结构体中。

## StrFormatByteSize

用于将字节数格式化为易读的文本格式。

```c++
BOOL WINAPI StrFormatByteSize(
  LARGE_INTEGER qdw,    // 字节数
  LPWSTR       pszBuf, // 缓存区
  UINT         cchBuf  // 缓存区大小
);
```

- `qdw` 参数表示要转换为文本格式的字节数，一般应该是一个 `LARGE_INTEGER` 类型的整数；-
- `pszBuf` 参数是一个缓存区，用于保存转换后的文本格式数据；
- `cchBuf` 参数表示缓存区的大小，以字符数为单位。

调用这个函数时，它会将 `qdw` 参数表示的字节数格式化为易读的文本格式，然后将结果保存到 `pszBuf` 缓存区中。

## VirtualQueryEx

查询指定进程中的虚拟内存地址空间信息

```c++
BOOL VirtualQueryEx(
  HANDLE                    hProcess, // 相关的进程句柄
  LPCVOID                   lpAddress, // 开始位置（指针）
  PMEMORY_BASIC_INFORMATION lpBuffer, // 缓冲区
  SIZE_T                    dwLength  // 缓冲区大小
);
```

该函数返回值为 `BOOL` 类型，表示操作是否成功。如果成功，将查询到的信息写入传入的 `MEMORY_BASIC_INFORMATION` 结构体指针中，可以通过结构体指针访问所有属性。

## MEMORY_BASIC_INFORMATION

```c++
typedef struct _MEMORY_BASIC_INFORMATION {
    PVOID BaseAddress;  // 虚拟内存基址
    PVOID AllocationBase;  // 分配页面的基址
    DWORD AllocationProtect;  // 标志页保护属性
    SIZE_T RegionSize;  // 区域大小
    DWORD State;  // 内存状态，如 MEM_COMMIT, MEM_FREE 等等。
    DWORD Protect;  // 保护标志
    DWORD Type;  // 内存类型，如 MEM_PRIVATE, MEM_MAPPED 等等。
} MEMORY_BASIC_INFORMATION, *PMEMORY_BASIC_INFORMATION;
```

- `Type`
  - `MEM_IMAGE`：映像文件页面。这些页面是从可执行映像文件中加载的。
  - `MEM_MAPPED`：映射文件页面。这些页面是通过调用 `MapViewOfFile` 或 `MapViewOfFileEx` 函数映射到文件的。
  - `MEM_PRIVATE`：私有页面。这些页面被进程专有，无法与其他进程共享。

## GetModuleFileName

用于获取指定模块的完整路径名

```c++
DWORD GetModuleFileName(
  HMODULE hModule,    // 模块句柄，如果为 NULL，则返回当前进程可执行文件的路径。
  LPTSTR lpFilename,  // 接收路径名的缓冲区指针。
  DWORD nSize         // 缓冲区的大小，以字符为单位。
);
```

- `hModule` 参数指定要检索其路径名的模块句柄，如果此参数为 `NULL`，则该函数将返回包含当前进程可执行文件名的完整路径。
- `lpFilename` 参数是一个指向接收路径名的缓冲区的指针。注意：缓冲区容量不能小于 MAX_PATH。
- `nSize` 参数指定缓冲区的大小（以字符为单位）。
- 当函数成功执行时，它将路径名复制到缓冲区中，并返回复制到缓冲区中的字符数目（不包括字符串终止符）。如果函数失败，则返回值为零。

##  PathStripPath

它从一个完整的路径名中提取文件名，并将其存储在缓冲区中。

```c++
void PathStripPath(
  LPTSTR pszPath  // 包含完整路径名的字符串指针。
);
```

- `pszPath` 参数是一个指向包含完整路径名的字符串的指针。该函数将从该路径名中提取文件名，并将其放置回原来的字符串缓冲区中。函数会自动分配空间，只需传递原字符串即可。

## SHOWMASK

```c++
#define SHOWWINDOW_MSG(wParam, lParam) ((void)(wParam), (int)(short)LOWORD(lParam))
#define SHOW_OPENWINDOW    1
#define SHOW_ICONWINDOW    2
#define SHOW_FULLSCREEN    3
#define SHOW_OPENNOACTIVATE 4
```

`SHOWMASK` 宏基于 `SHOWWINDOW_MSG` 宏。当接收到 `WM_SHOWWINDOW` 消息时，可以使用 `SHOWMASK` 宏来提取窗口的显示状态，

# Liunx下的进程控制

## pthread_t

`pthread_t` 是 POSIX 线程库中使用的一种数据类型，表示线程标识符。每个线程都有一个唯一的 `pthread_t` 值来标识它。POSIX 线程库提供了一些函数来操作线程，例如创建新线程、等待线程结束、终止线程等，这些函数通常需要传递一个 `pthread_t` 参数以标识要操作的线程。

`pthread_t` 类型实际上是一个不透明的结构体指针，其内部的属性和实现方式都是由具体的操作系统决定的。因此，我们不能对 `pthread_t` 对象进行直接操作，而是应该使用相关的函数来创建、获取、使用和销毁线程标识符。

## sem_init

`sem_init` 是 POSIX 信号量（Semaphore）机制库提供的一个函数，用于初始化一个信号量。信号量可以用来实现线程之间的同步和互斥机制，通常在多线程编程中使用。

```c++
int sem_init(sem_t *sem, int pshared, unsigned int value);
```

其中：

- `sem`：指向要初始化的信号量的指针，是一个类型为 `sem_t` 的变量。
- `pshared`：指定信号量的类型。它可以取两个值，如果为 0，则表示此信号量只能在同一进程内的线程之间共享；如果不为 0，则表示此信号量可以在多个进程间共享。
- `value`：指定信号量的初始值，即该信号量最多允许多少个线程同时访问某个资源。

`sem_init` 函数成功返回 0，失败返回 -1，同时设置 `errno` 变量来指示错误原因。

## pthread_create

`pthread_create` 函数是 POSIX 线程库（Pthreads）提供的一个函数，用于创建一个新的线程。

```c
int pthread_create(pthread_t *thread, const pthread_attr_t *attr,void *(*start_routine)(void*), void *arg);
```

其中：

- `thread`：指向线程标识符的指针。在成功创建线程后，该指针将被设置为新线程的 ID。
- `attr`：线程属性对象的指针。可以使用 `NULL` 表示默认线程属性。
- `start_routine`：指向线程主函数的指针，该函数用来执行新线程的任务。该函数的参数和返回值类型都为 `void*`。
- `arg`：传递给线程主函数的参数。

`pthread_create` 函数成功返回 0，失败返回一个非 0 的错误码，通过 `errno` 变量来指示错误原因。

## pthread_join

`pthread_join` 函数是 POSIX 线程库（Pthreads）提供的一个函数，用于等待一个线程结束，并获取其返回值。它的原型如下：

```c
pthread_join(pthread_t thread, void **retval);
```

其中：

- `thread`：要等待的线程 ID。
- `retval`：指向线程返回值的指针。

`pthread_join` 函数成功返回 0，失败返回一个非 0 的错误码，通过 `errno` 变量来指示错误原因。

## sem_wait

`sem_wait` 函数是 POSIX 信号量库提供的一个函数，用于阻塞并等待一个信号量的值变为大于 0，然后将信号量的值减一。其原型如下：

```
sem_wait(sem_t *sem);
```

其中：

- `sem`：指向要操作的信号量的指针。

`sem_wait` 函数成功返回 0，失败返回一个非 0 的错误码，通过 `errno` 变量来指示错误原因。

## sem_post

`sem_post` 函数是 POSIX 信号量库提供的一个函数，用于将指定信号量的值加一并唤醒等待该信号量的线程。其原型如下：

```c
sem_post(sem_t *sem);
```

其中：

- `sem`：指向要操作的信号量的指针。

`sem_post` 函数成功返回 0，失败返回一个非 0 的错误码，通过 `errno` 变量来指示错误原因。

## usleep

`usleep` 函数是一个 POSIX 标准函数，用于使当前进程挂起指定的微秒数。其原型如下：

```c++
int usleep(useconds_t microseconds);
```

其中：

- `microseconds`：要挂起的微秒数，以 unsigned int 类型表示。

`usleep` 函数会使当前进程挂起指定的微秒数，然后继续执行。如果指定的微秒数太大，可能会导致函数执行时间超时或者无法处理信号。

## sleep

`sleep` 函数是一个标准库函数，用于使当前线程挂起指定的秒数。其原型如下：

```c++
unsigned int sleep(unsigned int seconds);
```

其中：

- `seconds`：要挂起的秒数，以 unsigned int 类型表示。

`sleep` 函数会使当前进程挂起指定的秒数，然后继续执行。如果指定的秒数太大，可能会导致函数执行时间超时或者无法处理信号。

## 读者写者问题

## 读者优先

```c
int count = 0;
信号量 busy = 1; // “读文件”和“写文件”的互斥锁
信号量 mutex = 1; // 变量 count 的互斥锁

Reader(){ // 读者进程
    while(1){
        P(mutex);
        count++; 
        if (count == 1){ 
            P(busy);
        }
        V(mutex);
        
        读文件; 
        
        P(mutex);
        count--; 
        if (count == 0){ 
            V(busy);
        }
        V(mutex);
    }
}

Writer(){ // 写者进程
    while(1){
        P(busy);
        写文件;
        V(busy);
    }
}
```

## 写者优先

```c
int ReaderCount = 0; // 读者数量
int WriterCount = 0; // 写者数量
信号量 Read = 1; // “读文件”的互斥锁
信号量 Write = 1; // “写文件”的互斥锁
信号量 ReaderMutex = 1; // 变量 ReaderCount 的互斥锁
信号量 WriterMutex = 1; // 变量 WriterCount 的互斥锁

Reader(){ // 读者进程
    while(1){
        P(Read); // 每个读进程都需要对 Read 加锁
        P(ReaderMutex); // 对 ReadCount 的互斥，实际上，上条语句已经兼有此功能，可以去掉
        ReaderCount++; 
        if (ReaderCount == 1){ // 如果是第一个读进程
            P(Write); // 则对写者上锁
        }
        V(ReaderMutex); // 对 ReadCount 的互斥，实际上，下条语句已经兼有此功能，可以去掉
        V(Read); // Read 解锁
        
        读文件; 
        
        P(ReaderMutex); // 对 ReadCount 的互斥
        ReaderCount--; 
        if (ReaderCount == 0){ // 如果是最后一个读进程
            V(Write); // 则对写者解锁
        }
        V(ReaderMutex); // 对 ReadCount 的互斥
    }
}

Writer(){ // 写者进程
    while(1){
        P(WriterMutex); // 对 WriterCount 的互斥
        WriterCount++; 
        if (WriterCount == 1){ // 如果是第一个写进程
            P(Read); // 则对读者上锁
        }
        V(WriterMutex); // 对 WriterCount 的互斥
        
        P(Write); // Write 加锁
        写文件; 
        V(Write); // Write 解锁
        
        P(WriterMutex); // 对 WriterCount 的互斥
        WriterCount--; 
        if (WriterCount == 0){ // 如果是最后一个写进程
            V(Read); // 则对读者解锁
        }
        V(WriterMutex); // 对 WriterCount 的互斥
    }
}
```

## 读写公平

```c
int count = 0;
信号量 queue = 1; // 实现“读写公平”的互斥锁，可以视为一个队列
信号量 busy = 1; // “读文件”和“写文件”的互斥锁
信号量 mutex = 1; // 变量 count 的互斥锁

Reader(){ // 读者进程
    while(1){
        P(queue); // 在无写进程请求时不需要进入队列
        P(mutex); // 该互斥量实际上是多余的，上面语句已经兼有互斥功能
        count++; 
        if (count == 1){ 
            P(busy);
        }
        V(mutex); // 该互斥量实际上是多余的，下面语句已经兼有互斥功能
        V(queue); // 恢复对共享文件的访问
        
        读文件; 
        
        P(mutex);
        count--; 
        if (count == 0){ 
            V(busy);
        }
        V(mutex);
    }
}

Writer(){ // 写者进程
    while(1){
        P(queue); // 在无其他写进程请求时不需要进入队列
        P(busy);
        写文件;
        V(busy);
        V(queue); // 恢复对共享文件的访问
    }
}
```

## 哲学家进餐问题

```c
semaphore chopstick[5]={1,1,1,1,1};
semaphore mutex = 1; // 互斥地取筷子

Pi (){ //i号哲学家的进程
	while(1){
         P(mutex);
		P(chopstick[i]); // 拿左
		P(chopstick[(i+1)%5]); // 拿右
		V(mutex);
		吃饭…
		V(chopstick[i]); // 放左
		V(chopstick[(i+1)%5]); // 放右
		思考…
	}
}
```

# 问题

- `sem_init`未定义，解决方法：`gcc -o prog prog.c -lpthread`
