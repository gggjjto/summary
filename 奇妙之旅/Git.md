# Git

## 1 - Git起步

### 1.1 版本控制

#### 本地版本控制系统 VCS

> RCS的工作原理是在硬盘上保存的补丁集（补丁是指文件修改前后的变化）
>
> 通过应用所以的补丁，可以重新计算各个版本的文件内容。
>
> 缺点：容易混淆

#### 集中化的版本控制系统 CVCS

> 代表：CVS , Subversion , Perforce
>
> 这一类系统都有单一的集中管理的服务器，保存所以文件的修订版本，而协同工作的人们都通过客户端连接到这台服务器，取出最新文件或者提交更新。
>
> 缺点：中央服务器的单点故障，无法协同工作，磁盘损坏，没有备份会丢失所有的数据

#### 分布式版本控制系统 DVCS

> 代表：Git , Mercurial , Bazaar , Darcs
>
> 这类系统，客户端并不只提取最新版本文件的文件快照，而是把代码仓库完整的镜像下来，包括完整的历史纪录。这么一来，任何一处协同工作的服务器发生故障，事后都可以用任何一个镜像出来的本地仓库恢复。因为每一次的克隆操作，实际上都是一次对代码仓库的完整备份。

### 1.2 Git简史

> 初定目标：
>
> - 速度
> - 简单的设计
> - 对非线性开发模式的强力支持（允许成千上万个并行开发的分支）
> - 完全分布式
> - 有能力高效管理类似Linux内核一样的超大规模项目（速度和数据量）
>
> 自诞生于 2005 年以来，Git 日臻成熟完善，在高度易用的同时，仍然保留着初期设定的目标。 它的速度飞快，极其适合管理大项目，有着令人难以置信的非线性分支管理系统。

### 1.3 Git是什么?

是一个什么样的系统？

#### 直接记录快照，而非差异比较

> 基于差异 ：将它们储存的的信息看作一组基本的文件和每个文件随时间逐步累积的差异。

> 储存项目随时间改变的快照：
>
> Git 更像是一个小型的文件系统，提供了许多以此为基础构建的超强工具，而不是一个简单的VCS。

#### 近乎所有操作都是本地执行

> 在Git中的绝大多数操作都只需要访问本地文件和资源，在离线或者没有VPN时，几乎可以进行任何操作

#### Git 保证完整性

> Git中所有的数据在储存前都计算校验和，然后以校验和来应用。这意味着不可能在Git不知情时更改任何文件内容或目录内容。若你在传送过程中丢失或损坏文件，Git就能发现。

> Git用以计算校验和的机制叫做SHA-1散列（哈希，hash）。
>
> 这是一个由 40 个十六进制字符（0-9 和 a-f）组成的字符串，基于 Git 中文件的内容或目录结构计算出来。
>
> Git 中使用这种哈希值的情况很多，你将经常看到这种哈希值。 实际上，Git 数据库中保存的信息都是以文件内容的哈希值来索引，而不是文件名。

#### Git一般只添加数据

> 你执行的 Git 操作，几乎只往 Git 数据库中 **添加** 数据。 你很难使用 Git 从数据库中删除数据，也就是说 Git 几乎不会执行任何可能导致文件不可恢复的操作。 

#### 三种状态

> 已修改：修改了文件，但还没有保存到数据库中
>
> 已暂存：对一个已修改文件的当前版本做了标记，使之包含在下次提交的快照中。
>
> 已提交：数据已经安全保存在本地数据库中。

> 工作目录、暂存区域以及 Git 仓库。
>
> 工作区：是对项目的某个版本独立提取出来的内容。 这些从 Git 仓库的压缩数据库中提取出来的文件，放在磁盘上供你使用或修改。
>
> 暂存区：是一个文件，保存了下次将要提交的文件列表信息，一般在 Git 仓库目录中。 按照 Git 的术语叫做“索引”，不过一般说法还是叫“暂存区”。
>
> Git 仓库目录：是 Git 用来保存项目的元数据和对象数据库的地方。 这是 Git 中最重要的部分，从其它计算机克隆仓库时，复制的就是这里的数据。
>
> 基本的 Git 工作流程：
>
> 1. 在工作区中修改文件
> 2. 将你想要下次提交的更改选择性地暂存，这样只会将更改的部分添加到暂存区。
> 3. 提交更新，找到暂存区的文件，将快照永久的储存到Git目录

如果 Git 目录中保存着特定版本的文件，就属于 **已提交** 状态。 如果文件已修改并放入暂存区，就属于 **已暂存** 状态。 如果自上次检出后，作了修改但还没有放到暂存区域，就是 **已修改** 状态。

### 1.4 命令行

> 只有在命令行模式下你才能执行 Git 的 **所有** 命令，而大多数的 GUI 软件只实现了 Git 所有功能的一个子集以降低操作难度。

### 1.5 安装Git

#### 在Windows上安装

> 两种方法：
>
> 1. 安装Git
> 2. 安装Github Desktop

### 1.6 初次运行Git前的配置

#### 初次运行Git前的配置

> Git 自带一个 `git config` 的工具来帮助设置控制 Git 外观和行为的配置变量。 这些变量存储在三个不同的位置：
>
> 1. `/etc/gitconfig` 文件: 包含系统上每一个用户及他们仓库的通用配置。 如果在执行 `git config` 时带上 `--system` 选项，那么它就会读写该文件中的配置变量。 （由于它是系统配置文件，因此你需要管理员或超级用户权限来修改它。）
>
> 2. `~/.gitconfig` 或 `~/.config/git/config` 文件：只针对当前用户。 你可以传递 `--global` 选项让 Git 读写此文件，这会对你系统上 **所有** 的仓库生效。
>
> 3. 当前使用仓库的 Git 目录中的 `config` 文件（即 `.git/config`）：针对该仓库。 你可以传递 `--local` 选项让 Git 强制读写此文件，虽然默认情况下用的就是它。。 （当然，你需要进入某个 Git 仓库中才能让该选项生效。）
>
>    ###### 每一个级别会覆盖上一级别的配置，所以 `.git/config` 的配置变量会覆盖 `/etc/gitconfig` 中的配置变量。

你可以通过以下命令查看所有的配置以及它们所在的文件：

>  `$ git config --list --show-origin` 

#### 用户信息

安装完 Git 之后，要做的第一件事就是设置你的用户名和邮件地址。 这一点很重要，因为每一个 Git 提交都会使用这些信息，它们会写入到你的每一次提交中，不可更改：

> ```console
> $ git config --global user.name "John Doe"
> $ git config --global user.email johndoe@example.com
> ```

再次强调，如果使用了 `--global` 选项，那么该命令只需要运行一次，因为之后无论你在该系统上做任何事情， Git 都会使用那些信息。 当你想针对特定项目使用不同的用户名称与邮件地址时，可以在那个项目目录下运行没有 `--global` 选项的命令来配置。

#### 文本编辑器

既然用户信息已经设置完毕，你可以配置默认文本编辑器了，当 Git 需要你输入信息时会调用它。 如果未配置，Git 会使用操作系统默认的文本编辑器。

例如 Emacs :

>  `$ git config --global core.editor emacs` 

 如果你在使用 32 位的 Windows 系统，或在 64 位系统上使用 64 位的编辑器，那么你需要输入如下命令：

> ```console
> $ git config --global core.editor "'C:/Program Files/Notepad++/notepad++.exe' -multiInst -notabbar -nosession -noPlugin"
> ```

#### 检查配置信息

如果想要检查你的配置，可以使用 `git config --list` 命令来列出所有 Git 当时能找到的配置。

你可能会看到重复的变量名，因为 Git 会从不同的文件中读取同一个配置（例如：`/etc/gitconfig` 与 `~/.gitconfig`）。 这种情况下，Git 会使用它找到的每一个变量的最后一个配置。

你可以通过输入 `git config <key>`： 来检查 Git 的某一项配置。

### 1.7 获取帮助

#### 获取帮助

若你使用 Git 时需要获取帮助，有三种等价的方法可以找到 Git 命令的综合手册（manpage）：

```console
$ git help <verb>
$ git <verb> --help
$ man git-<verb>
```

此外，如果你不需要全面的手册，只需要可用选项的快速参考，那么可以用 `-h` 选项获得更简明的 “help” 输出：

> `$ git add -h`

###  1.8 总结

在自己的电脑上安装了一个Git，对Git是什么，有什么用有了基本的了解。

#### Git常用命令

```
$ git status
$ git add 要添加到暂存区的文件名
$ git rm --cached  删除暂存区的文件名
$ git commit -m "提交说明" 提交的文件 
$ git push
$ git reflog
$ git log
$ git reset --hard 版本号

```



## Git基础 

 在学习完本章之后，你应该能够配置并初始化一个仓库（repository）、开始或停止跟踪（track）文件、暂存（stage）或提交（commit）更改。

### 2.1 获取Git仓库

#### 获取Git仓库

通常获取Git项目仓库的两种方式：

1. 将尚未进行版本控制的本地目录转换为Git仓库。
2. 从其他服务器**克隆**一个已经存在的Git仓库。

本地机器上可以得到一个工作就绪的Git仓库。

#### 在已存在的目录中初始化仓库

在Windows上：

```console
$ cd /c/user/my_project
$ git init
```

该命令将创建一个名为 `.git` 的子目录，这个子目录含有你初始化的 Git 仓库中所有的必须文件，这些文件是 Git 仓库的骨干。**但是，在这个时候，我们仅仅是做了一个初始化的操作，你的项目里的文件还没有被跟踪。**

如果在一个已存在文件的文件夹（而非空文件夹）中进行版本控制，你应该开始追踪这些文件并进行初始提交。 可以通过 `git add` 命令来指定所需的文件来进行追踪，然后执行 `git commit` ：

#### 克隆现有的仓库

如果你想获得一份已经存在了的 Git 仓库的拷贝,这时就要用到 `git clone` 命令。

克隆仓库的命令是 `git clone <url>` 。

比如，要克隆Git的连接库，可以用到下面的命令：

```console
$ git clone https://github.com/libgit2/libgit2
```

如果你想在克隆远程仓库的时候，自定义本地仓库的名字，你可以通过额外的参数指定新的目录名：

```console
$ git clone https://github.com/libgit2/libgit2 mylibgit
```

要是报错：`SSL certificate problem: unable to get local issuer certificate`

则把git中的sslverify关掉：
```shell
$ git config --global http.sslverify false
```

Git 支持多种数据传输协议。 上面的例子使用的是 `https://` 协议，不过你也可以使用 `git://` 协议或者使用 SSH 传输协议，比如 `user@server:path/to/repo.git` 。

### 2.2 记录每次更新到仓库 

#### 记录每次更新到仓库

你会对这些文件做些修改，每当完成了一个阶段的目标，想要将记录下它时，就将它提交到仓库。

文件会有两种状态：**已跟踪**和**未跟踪**。

**已跟踪的文件**是指那些被纳入了版本控制的文件，在上一次快照中有它们的记录，在工作一段时间后， 它们的状态可能是未修改，已修改或已放入暂存区。简而言之，已跟踪的文件就是*** Git 已经知道的文件**。

**工作目录中除已跟踪文件外的其它所有文件都属于未跟踪文件**，它们既不存在于上次快照的记录中，也没有被放入暂存区。 **初次克隆某个仓库的时候，工作目录中的所有文件都属于已跟踪文件，并处于未修改状态**，因为 Git 刚刚检出了它们， 而你尚未编辑过它们。

#### 检查当前文件状态

> 可以用```git status``` 命令查看哪些文件处于什么状态。
>
> 该命令还显示了当前所在分支。

#### 跟踪新文件

使用``` git add ``` 开始跟踪一个文件。所以，要跟踪``README``文件，运行：

``` shell
$ git add README
```

在运行`` git status ``命令，会看到文件``README``已被跟踪，并处于暂存状态。

只要在 `Changes to be committed` 这行下面的，就说明是已暂存状态。 如果此时提交，那么该文件在你运行 `git add` 时的版本将被留存在后续的历史记录中。 你可能会想起之前我们使用 `git init` 后就运行了 `git add <files>` 命令，开始跟踪当前目录下的文件。 `git add` 命令使用文件或目录的路径作为参数；如果参数是目录的路径，该命令将**递归**地跟踪该目录下的所有文件。

#### 暂存已修改的文件

在修改了一个已被跟踪的文件后，使用``` git status```命令后，会看到文件名``Changes not staged for commit``这行下面出现，说明文件内容发生了变化。

``git add`` :  这是个多功能命令：可以用它开始跟踪新文件，或者把已跟踪的文件放到暂存区，还能用于合并时把有冲突的文件标记为已解决状态等。理解为  **精确地将内容添加到下一次提交中**

在执行 ``git add`` 和``git status`` 时，会出现时间差异，暂存时的文件版本是``git add``时的版本，使用 ``git status`` 查看状态时是最新的改动的版本。

``` 
如果你现在提交，CONTRIBUTING.md 的版本是你最后一次运行 git add 命令时的那个版本，而不是你运行 git commit 时，在工作目录中的当前版本。 所以，运行了 git add 之后又作了修订的文件，需要重新运行 git add 把最新版本重新暂存起来
```

#### 状态简览

`git status` 命令的输出十分详细，但其用语有些繁琐。 Git 有一个选项可以帮你缩短状态命令的输出，这样可以以简洁的方式查看更改。

```shell
$ git status -s
```

~~~shell
$ git status -short
~~~

> ?? : 新添加的未跟踪文件
>
> A : 新添加到暂存区的文件
>
> M : 修改过的文件
>
> MM : 文件已修改,暂存后又作了修改（因此该文件中既有已暂存的部分，又有未暂存的部分）

#### 忽略文件

一般我们都有些文件无需纳入Git的管理，也不希望它们总出现在未跟踪文件列表。 通常都是些自动生成的文件，比如日志文件，或者编译过程中创建的临时文件等。 在这种情况下，我们可以创建一个名为 `.gitignore` 的文件，列出要忽略的文件的模式。

要养成一开始就为你的新仓库设置好 .gitignore 文件的习惯，以免将来误提交这类无用的文件。

文件``.gitignore`` 的格式规范如下 ：

- 所有空格或者以``#`` 开头的行都会被 Git 忽略。

- 可以使用标准的 glob 模式匹配，它会递归地应用在整个工作区。
- 匹配模式可以以（``/``)开头防止递归。
- 匹配模式可以以（``/``）结尾指定目录。
- 要忽略指定模式以外的文件或目录，可以在模式前加上叹号（``!``）取反。

> 1. 所谓的 glob 模式是指 shell 所使用的简化了的正则表达式。
> 2.  星号（`*`）匹配零个或多个任意字符。
> 3. `[abc]` 匹配任何一个列在方括号中的字符 （这个例子要么匹配一个 a，要么匹配一个 b，要么匹配一个 c）。
> 4.  问号（`?`）只匹配一个任意字符。
> 5. 如果在方括号中使用短划线分隔两个字符， 表示所有在这两个字符范围内的都可以匹配（比如 `[0-9]` 表示匹配所有 0 到 9 的数字）。
> 6.  使用两个星号（`**`）表示匹配任意中间目录，比如 `a/**/z` 可以匹配 `a/z` 、 `a/b/z` 或 `a/b/c/z` 等。

#### 查看已暂存和未暂存的修改